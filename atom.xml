<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lyn&#39;s blog</title>
  
  <subtitle>咸鱼王子</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://www.lynth.cn/blog/"/>
  <updated>2022-05-30T07:22:31.465Z</updated>
  <id>http://www.lynth.cn/blog/</id>
  
  <author>
    <name>Lyn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 uniapp 和 vant 的遇到问题记录</title>
    <link href="http://www.lynth.cn/blog/2021/uniapp.html"/>
    <id>http://www.lynth.cn/blog/2021/uniapp.html</id>
    <published>2021-07-15T14:00:00.000Z</published>
    <updated>2022-05-30T07:22:31.465Z</updated>
    
    <content type="html"><![CDATA[<p>在项目中需要用<code>vant</code>组件库的<code>ImagePreview</code>组件遇到报错，导致组件无法正常使用。</p><span id="more"></span><p>按照<code>vant</code>的文档使用<code>ImagePreview</code>时，浏览器抛出了下面的异常错误：<br><img src="/blog/images/uniapp采坑记录1-1.png" alt="错误提示"></p><p>通过浏览器断点调试，发现是<code>ImagePreview</code>组件中的<code>ImagePreviewItem</code>组件在渲染<code>Image</code>组件时报错了，如下图：<br><img src="/blog/images/uniapp采坑记录1-2.png" alt="错误提示"></p><p>从报错中看到<code>this.onLoad</code>方法是<code>undefined</code>,从图中还可以看到已经定义过<code>onLoad</code>方法了，那为什么<code>onLoad</code>方法消失了呢？</p><h2 id="探索原因"><a href="#探索原因" class="headerlink" title="探索原因"></a>探索原因</h2><p><code>uniapp</code><a href="https://uniapp.dcloud.net.cn/frame?id=%e9%a1%b5%e9%9d%a2%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f">官方文档</a>中写着页面的生命周期中包含<code>onLoad</code>方法，怀疑是与此方法冲突导致，但是为什么会影响到组件<code>methods</code>中方法还未知原因。</p><p>然后我再一个普通的页面的<code>methods</code>中也写了一个<code>onLoad</code>方法，发现他竟然直接被当做生命周期执行了，绑定在<code>DOM</code>上的<code>onLoad</code>也变成了<code>undefiend</code>。现在有理由证明是<code>uniapp</code>对页面或组件的<code>vue</code>实例进行操作。</p><p>经过翻阅<code>uniapp</code>的<a href="https://github.com/dcloudio/uni-app/blob/0edd43ecafaebd2b7a638ecccf3d527702eecf43/src/core/service/plugins/lifecycle.js#L79">源码</a>发现，他为了支持自己框架的一些<code>life cycle hooks</code>，对页面或组件的<code>vue</code>实例进行了<code>mixin</code>操作，可以看到，当页面或组件的<code>methods</code>包含了与框架生命周期同名的函数，将会被直接绑定实例外层，然后从<code>methods</code>中删除。<br><img src="/blog/images/uniapp采坑记录1-3.png" alt="错误提示"><br>经过<code>debug</code>，也完全证实了上面的结论。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>既然已经发现了问题的原因，那要如何解决问题呢？<code>uniapp</code>和<code>vant</code>都是第三方库,去给他们提<code>issue</code>让两边的团队去协商解决吧，这显然是不可能的。或者放弃使用<code>uniapp</code>或者<code>vant</code>？这个主意不错，但是并不能解决根本问题，当你发现其他<code>vant</code>组件或其他者第三方组件也有冲突时，要怎么办呢。</p><p>我想到代码都是要通过<code>babel</code>转义的，那我是不是能通过<code>babel-plugin</code> 来解决呢？后来发现，项目中的<code>babel-plugin</code>只能对本地代码的<code>AST</code>语法树进行操作，并不能解析到第三方库的代码，因为他们都是通过<code>import</code>导入进来的，<code>babel-plugin</code>只能解析到<code>import</code>的<code>AST</code>。</p><p>仔细一想，解析第三方库的话，用<code>babel-loader</code>就好了。于是我便写了一个替换方法名的<code>loader</code>，并在<code>vue.config.js</code>中添加了对<code>vant</code>库的<code>loader</code>。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fixConflictLoader.js</span></span><br><span class="line"><span class="keyword">const</span> mixedNameReg = <span class="regexp">/\b(onLoad|onError)\b/g</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">source</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _source = source;</span><br><span class="line">  <span class="keyword">if</span> (mixedNameReg.<span class="title function_">test</span>(_source)) &#123;</span><br><span class="line">    _source = _source.<span class="title function_">replace</span>(mixedNameReg, <span class="keyword">function</span> (<span class="params">$<span class="number">0</span></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> $<span class="number">0</span> + <span class="string">&quot;InVant&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> _source;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> fixConflictLoader = path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;./fixConflictLoader&quot;</span>);</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.<span class="property">module</span></span><br><span class="line">    .<span class="title function_">rule</span>(<span class="string">&quot;compile&quot;</span>)</span><br><span class="line">    .<span class="title function_">test</span>(<span class="regexp">/\.js$/</span>)</span><br><span class="line">    .<span class="property">include</span>.<span class="title function_">add</span>(<span class="title function_">resolve</span>(<span class="string">&quot;node_modules/vant/es&quot;</span>)) <span class="comment">// vant 的按需引入使用的是此项目包</span></span><br><span class="line">    .<span class="title function_">end</span>()</span><br><span class="line">    .<span class="title function_">use</span>(fixConflictLoader)</span><br><span class="line">    .<span class="title function_">loader</span>(fixConflictLoader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个方法非常的暴力，直接解析<code>vant</code>的源码，然后批量替换其中与<code>uniapp</code>生命周期冲突的方法名，实际也解决了我所遇到的问题。</p><p><strong>如果你有更好的方法，欢迎与我探讨交流。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在项目中需要用&lt;code&gt;vant&lt;/code&gt;组件库的&lt;code&gt;ImagePreview&lt;/code&gt;组件遇到报错，导致组件无法正常使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.lynth.cn/blog/tags/Javascript/"/>
    
      <category term="uniapp" scheme="http://www.lynth.cn/blog/tags/uniapp/"/>
    
      <category term="vant" scheme="http://www.lynth.cn/blog/tags/vant/"/>
    
  </entry>
  
  <entry>
    <title>多途径唤起小程序方案研究</title>
    <link href="http://www.lynth.cn/blog/2021/open-xcx-by-link.html"/>
    <id>http://www.lynth.cn/blog/2021/open-xcx-by-link.html</id>
    <published>2021-02-15T14:00:00.000Z</published>
    <updated>2022-05-30T07:22:31.465Z</updated>
    
    <content type="html"><![CDATA[<p>了解如何在微信外跳转到微信小程序。</p><span id="more"></span><h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><p>在运营过程中，希望通过多种渠道引流到小程序，比如：</p><ol><li>APP中，点击能够直接打开小程序对应页面</li><li>短信或邮件中，点击链接可以直接打开小程序对应页面</li><li>H5页面中，点击能直接打开小程序对应页面</li></ol><p>本文将从这三点展开研究。</p><h2 id="APP唤起小程序"><a href="#APP唤起小程序" class="headerlink" title="APP唤起小程序"></a>APP唤起小程序</h2><p>考虑到部分场景下 APP 需要通过小程序来承载服务，微信<code>JS-SDK</code> 提供了移动应用（APP）拉起小程序功能。移动应用（APP）接入此功能后，用户可以在 APP 中跳转至微信某一小程序的指定页面，<strong>完成服务后再跳回至原 APP</strong> (关于小程序唤起APP功能，这又是另外一个功能点了，我们下篇文章再展开讲)。</p><p>既然微信<code>JS-SDK</code> 提供了此能力，那么只需要<code>APP</code>接入微信的<code>JS-SDK</code>，并且符合官方的跳转规则要求，即可以实现<code>APP</code>打开小程序的功能。这里就不多追溯了，本文主要探讨短信、邮件和H5的场景。</p><h2 id="短信、邮件唤起小程序"><a href="#短信、邮件唤起小程序" class="headerlink" title="短信、邮件唤起小程序"></a>短信、邮件唤起小程序</h2><p>早在2021年之前，大家可能会说这个不可能实现，只有两种替代方案：</p><p>1.直接短信提示用户，让用户打开微信搜索小程序名称进入</p><p>2.跳转到H5网页，在网页里面用图片或者文字做引导，让用户搜索或者扫码进入小程序。</p><p>我所在的公司曾经就用的第二种方案。由于各种偏差，预想投放出去的物料上的二维码能直接打开小程序，结果是一个H5空壳链接，于是就在H5页面中利用文字图片引导用户扫码或搜索打开小程序。可想而知，这样引流的效果会大打折扣，谁不想能一步到位呢。</p><p>现如今，微信推出了小程序的<code>URL Scheme</code>，获取小程序的<code>Scheme</code>码，可适用于从短信、邮件、微信外网页等场景打开小程序。但是事情永远都不会那么简单，不同的系统兼容性也会出现问题。</p><p><code>IOS</code>系统支持识别<code>URL Scheme</code>，可以在短信等应用场景中直接用过<code>Scheme</code>码打开小程序。</p><p><code>Android</code>系统不支持直接识别<code>URL Scheme</code>，用户无法通过<code>Scheme</code>正常打开小程序，开发者需要使用H5页面中转，再跳转到<code>Scheme</code>实现打开小程序，方案就是利用网页的重定向打开小程序。可以在用户打开H5页面或者触发事件后调用<code>location.href = &#39;weixin://dl/business/?t= *TICKET*&#39;</code>。</p><p>所以考虑到兼容性问题，我们必须用一个H5页面做承接页来做中转站。</p><h2 id="H5唤起小程序"><a href="#H5唤起小程序" class="headerlink" title="H5唤起小程序"></a>H5唤起小程序</h2><p>通过对短信唤起小程序的研究，我们知道H5只需要作为一个中转站，调用一个重定向方法执行<code>Scheme</code>码就可以跳转到小程序。</p><h2 id="小程序URL-Scheme"><a href="#小程序URL-Scheme" class="headerlink" title="小程序URL Scheme"></a>小程序URL Scheme</h2><p>根据微信官方文档描述，<code>Scheme</code>码必须通过<strong>服务端的接口</strong>获取或者通过小程序管理后台生成，生成的<code>URL Scheme</code>如下所示：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">weixin:<span class="regexp">//</span>dl<span class="regexp">/business/</span>?t= *TICKET*</span><br></pre></td></tr></table></figure><p>利用此<code>Scheme</code>码通过H5做承接页跳转，就可以在<code>Android</code>和<code>IOS</code>平台下，通过短信、邮件、<strong>微信外网页</strong>等场景打开小程序。</p><p>事情往往没有那么简单，可能你也注意到了，<code>URL Scheme</code>只适用于<strong>微信外网页</strong>，那么如果H5页面在微信内被打开了会发生什么呢。经测试，微信内打开如下图所示：</p><p><img src="/blog/images/wxwrong.png" alt="微信内打开错误提示">  </p><p>微信内部无法解析<code>URL Scheme</code>,那微信内部需要通过H5打开小程序要怎么做呢？微信官方也给出了方法：微信内的网页如需打开小程序请使用<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#开放标签说明文档">微信开放标签-小程序跳转按钮</a>。</p><p>通过上面的研究我们可以总结出：要实现微信内和微信外多场景跳转到小程序，我们需<strong>小程序 URL Scheme </strong>和<strong>微信开放标签</strong>。</p><h4 id="获取-URL-Scheme"><a href="#获取-URL-Scheme" class="headerlink" title="获取 URL Scheme"></a>获取 URL Scheme</h4><p>如果想要通过H5网页跳转到小程序的任意页面，肯定是需要通过向服务端传参，然后服务端生成小程序对应页面<code>Scheme</code>码返回给前端，才能适应此场景。如果想要固定跳转首页的话，直接通过小程序管理后台的「工具」生成即可。此场景过于简单，本文不做探讨，下面将介绍服务端如何生成<code>URL Scheme</code>。</p><p>服务端获取<code>URL Scheme</code>需要调用<a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-scheme/urlscheme.generate.html#%E4%BA%91%E8%B0%83%E7%94%A8">微信的官方API</a>：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">POST https:<span class="regexp">//</span>api.weixin.qq.com<span class="regexp">/wxa/g</span>eneratescheme?access_token=ACCESS_TOKEN</span><br></pre></td></tr></table></figure><p>请求参数说明：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">access_token</td><td style="text-align:center"><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html">接口调用凭证</a></td></tr><tr><td style="text-align:center">jump_wxa</td><td style="text-align:center">跳转到的目标小程序信息</td></tr><tr><td style="text-align:center">is_expire</td><td style="text-align:center">生成的scheme码类型，到期失效：true，永久有效：false。</td></tr><tr><td style="text-align:center">expire_time</td><td style="text-align:center">到期失效的scheme码的失效时间</td></tr></tbody></table><p>从参数中我们可以看出两个关键信息：</p><p>1.<code>Scheme</code>将根据是否到期参数与失效时间参数，分为<strong>短期有效Scheme</strong>与<strong>长期有效Scheme</strong>。有效时间超过31天的<code>Scheme</code>或永久有效的<code>Scheme</code>被视为<strong>长期有效Scheme</strong>，单个小程序总共可生成长期有效<code>Scheme</code>上限为10万个。有效时间不超过31天的<code>Scheme</code>为<strong>短期有效Scheme</strong>，单个小程序生成短期有效<code>Scheme</code>不设上限。所以我们需要在服务端生成有效期为30天的<code>Scheme</code>就可以无限次生成了。并利用<code>Redis</code>缓存数据，30天过期后再从新生成新的30天有效期的<code>Scheme</code>。</p><p>2.获取<code>Scheme</code>码是需要权限的。参数<code>access_token</code>是获取小程序全局唯一后台接口调用凭据。<strong>调用绝大多数后台接口时都需使用 access_token，开发者需要进行妥善保存。</strong>（在后续的<strong>微信开放标签</strong>中，我们还需要使用它）</p><h4 id="获取-token"><a href="#获取-token" class="headerlink" title="获取 token"></a>获取 token</h4><p>服务端通过微信官方API来获取<code>access_token</code>：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">GET https:<span class="regexp">//</span>api.weixin.qq.com<span class="regexp">/cgi-bin/</span>token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</span><br></pre></td></tr></table></figure><p>重要请求参数说明：</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">appid</td><td style="text-align:center">小程序唯一凭证，即 AppID，在微信公众平台-小程序设置里获取。</td></tr><tr><td style="text-align:center">secret</td><td style="text-align:center">小程序唯一凭证密钥，即 AppSecret，获取方式同 appid</td></tr></tbody></table><p>官方接口将会返回<code>access_token</code>，<code>access_token</code> 的有效期为 <strong>2 个小时</strong>。服务端需要使用中控服务统一获取和刷新<code>access_token</code>，其他业务逻辑服务器所使用的 <code>access_token</code> 均来自于该中控服务器，不应该各自去刷新，否则容易造成冲突，导致 <code>access_token</code> 覆盖而影响业务。</p><h4 id="微信开放标签"><a href="#微信开放标签" class="headerlink" title="微信开放标签"></a>微信开放标签</h4><p>微信开放标签是微信公众平台面向网页开发者提供的扩展标签集合。通过使用微信开放标签，网页开发者可安全便捷地使用微信或系统的能力，为微信用户提供更优质的网页体验。需要使用微信开放标签，<strong>必须在前端工程中引入微信的<code>JS-SDK</code>，而且必须要有一个认证了服务号的公众号，需要在公众号后台中绑定JS接口安全域名，在绑定的安全域名下的网页，才能正常调用<code>JS-SDK</code></strong>。使用开放标签的能力，可以跳转到任意合法合规的小程序。</p><p>微信标签使用步骤：</p><ol><li>绑定域名：进入到微信公众平台，在公众号的功能设置中添加“JS接口安全域名”</li><li>在项目中引用<code>JS-SDK</code>文件：<code>https://res.wx.qq.com/open/js/jweixin-1.6.0.js</code></li><li>通过wx.config注入权限验证配置并申请所需开放标签，示例代码如下：</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">config</span>(&#123;</span><br><span class="line">  <span class="attr">debug</span>: <span class="literal">true</span>, <span class="comment">// 开启调试模式</span></span><br><span class="line">  <span class="attr">appId</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，服务号的唯一标识</span></span><br><span class="line">  <span class="attr">timestamp</span>: , <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">  <span class="attr">nonceStr</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">  <span class="attr">signature</span>: <span class="string">&#x27;&#x27;</span>,<span class="comment">// 必填，签名</span></span><br><span class="line">  <span class="attr">jsApiList</span>: [<span class="string">&#x27;checkJsApi&#x27;</span>], <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">  <span class="attr">openTagList</span>: [<span class="string">&#x27;wx-open-launch-weapp&#x27;</span>] <span class="comment">// 可选，需要使用的开放标签列表</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="4"><li>通过<code>wx.ready(() =&gt; function()&#123;&#125;)</code>和<code>wx.error(() =&gt; function(res)&#123;&#125;)</code>来处理验证成功和失败的情景</li></ol><p>很多人容易卡在第三步，因为第三步是最麻烦也是需要特别注意的地方，稍微出点差错就会导致权限认证失败，导致微信开放标签无法显示或点击无效。</p><p>根据我的研究，我汇总了以下需要特别注意的地方：</p><ul><li>认真仔细的阅读<a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62">JS-SDK使用权限</a></li><li>检查代码里的<code>appid</code>和公众号后台的<code>id</code>是否一致</li><li>检查JS接口安全域名是否配置正确，只需要配置顶级域名，非80端口需要加端口号</li><li>签名要用到的<code>access_token</code>和<code>jsapi_ticket</code>必须要缓存起来的</li><li>确认<code>config</code>中的 <code>nonceStr</code>和签名中的<code>noncestr</code>的大小写，要注意辨别</li><li>签名中的<code>url</code>在<code>JavaScript</code>中是通过<code>location.href.split(&#39;#&#39;)[0]</code>获取的</li><li>通过微信官方提供的<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=jsapisign">签名校验工具</a>验证生成的签名是否正确</li></ul><h4 id="打开小程序流程"><a href="#打开小程序流程" class="headerlink" title="打开小程序流程"></a>打开小程序流程</h4><p>在考虑<code>IOS</code>和<code>Android</code>的兼容性还有<code>URL Scheme</code>在微信内和微信外被打开之后有不同表现的情况下，我总结出通过邮件、短信、H5等方式打开小程序的流程大致如下图：</p><p><img src="/blog/images/打开小程序流程.png" alt="打开小程序流程">  </p><p><strong>从上图可以看出，用户可以选择取消打开小程序，所以我们需要妥善处理用户拒绝打开小程序后的场景。</strong></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>如果你觉得上面的各种关联设置很麻烦，微信也给你提供了省事的方式，那就是使用小程序的<a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html">云开发</a>。<strong>非个人主体并且已认证的</strong>小程序，使用云开发静态网站托管的网页，可以<strong>免鉴权</strong>跳转任意合法合规的小程序。</p><p>当然，本文没有使用云开发的方式。本文采用了静态网站和服务端相结合的方式，我也写出了一个简略的体验DEMO，你可以通过点击<a href="https://m.idongjia.cn/test/h5/xcxJumpPage"><strong>【DEMO】</strong></a>来感受一下我的研究成果吧。</p><hr><blockquote><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/url-scheme.html">微信官方文档·小程序 - URL Scheme</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/url-scheme/urlscheme.generate.html">微信官方文档·小程序 - urlscheme.generate</a></p><p><a href="https://developers.weixin.qq.com/miniprogram/dev/wxcloud/guide/staticstorage/jump-miniprogram.html">微信官方文档·小程序·云开发 - 静态网站H5跳小程序</a></p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_Open_Tag.html#%E5%BC%80%E6%94%BE%E6%A0%87%E7%AD%BE%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3">微信官方文档·公众号 - 开放标签说明文档</a></p><p><a href="https://developers.weixin.qq.com/doc/oplatform/Mobile_App/Launching_a_Mini_Program/Launching_a_Mini_Program.html">微信官方文档·开放平台 - APP拉起小程序功能</a></p><p><a href="https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/JS-SDK.html#62">JS-SDK说明文档 - 权限签名算法</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解如何在微信外跳转到微信小程序。&lt;/p&gt;
    
    </summary>
    
    
      <category term="小程序" scheme="http://www.lynth.cn/blog/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>手撸一个简易的webpack</title>
    <link href="http://www.lynth.cn/blog/2020/simple-webpack.html"/>
    <id>http://www.lynth.cn/blog/2020/simple-webpack.html</id>
    <published>2020-08-14T15:00:00.000Z</published>
    <updated>2022-05-30T07:22:31.465Z</updated>
    
    <content type="html"><![CDATA[<p>动手写一个简单的代码编译器，了解一下<code>webpack</code>的核心原理。</p><span id="more"></span><h2 id="核心打包原理"><a href="#核心打包原理" class="headerlink" title="核心打包原理"></a>核心打包原理</h2><ol><li>获取入口文件的内容</li><li>分析入口文件，读取需要执行的模块内容</li><li>生成 AST 语法树</li><li>根据 AST 语法树生成浏览器能够正常运行的代码</li></ol><h2 id="撸代码"><a href="#撸代码" class="headerlink" title="撸代码"></a>撸代码</h2><p>首先初始化一个项目</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">webpackTheory</span><br><span class="line"> ├── src</span><br><span class="line"> │   ├── sum.js</span><br><span class="line"> │   ├── subtract.js</span><br><span class="line"> │   └── index.js</span><br><span class="line"> ├── package.json</span><br><span class="line"> ├── bundle.js</span><br><span class="line"> └── index.html</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (a, b) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// subtract.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">minus</span> = (<span class="params">a, b</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">&#x27;./sum.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    minus</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./subtract.js&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> sum = <span class="title function_">add</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> subtract = <span class="title function_">minus</span>(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">`&lt;h1&gt;sum:<span class="subst">$&#123;sum&#125;</span>&lt;/h1&gt;&lt;h1&gt;subtract:<span class="subst">$&#123;subtract&#125;</span>&lt;/h1&gt;`</span>)</span><br></pre></td></tr></table></figure><p>如果此时直接在<code>index.html</code>中引入<code>index.js</code>，页面是无法正常运行的，浏览器无法正常解析，就会抛出语法错误。</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">Uncaught SyntaxError<span class="punctuation">:</span> Cannot use import statement outside a module</span><br></pre></td></tr></table></figure><p>所以需要一个编译器，把<code>index.js</code>编译成浏览器能够正常解析的语法。</p><p>创建一个<code>bundle.js</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bundle.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 2️⃣ https://babeljs.io/docs/en/babel-parser</span></span><br><span class="line"><span class="comment">* 用来把 JS 生成 AST 语法树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&quot;@babel/parser&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 3️⃣  https://babeljs.io/docs/en/babel-traverse</span></span><br><span class="line"><span class="comment">* 用来遍历 AST，可以添加、删除和更新节点，这里主要用来获取依赖文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&quot;@babel/traverse&quot;</span>).<span class="property">default</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3️⃣</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 4️⃣  https://babeljs.io/docs/en/babel-core</span></span><br><span class="line"><span class="comment">* Babel 的核心功能包，这里用来把 AST 语法树转换成可执行的 JS </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&quot;@babel/core&quot;</span>);   </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getModuleInfo</span> = (<span class="params">file</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取执行代码</span></span><br><span class="line">  <span class="keyword">const</span> body = fs.<span class="title function_">readFileSync</span>(file, <span class="string">&quot;utf-8&quot;</span>); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2️⃣ 生成 ast tree</span></span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">AST</span> = parser.<span class="title function_">parse</span>(body, &#123;</span><br><span class="line">    <span class="attr">sourceType</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> deps = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 3️⃣ 解析依赖</span></span><br><span class="line">  <span class="title function_">traverse</span>(<span class="variable constant_">AST</span>, &#123;</span><br><span class="line">    <span class="title class_">ImportDeclaration</span>(&#123;</span><br><span class="line">      node</span><br><span class="line">    &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> dirname = path.<span class="title function_">dirname</span>(file);</span><br><span class="line">      <span class="keyword">const</span> abspath = <span class="string">&quot;./&quot;</span> + path.<span class="title function_">join</span>(dirname, node.<span class="property">source</span>.<span class="property">value</span>);</span><br><span class="line">      deps[node.<span class="property">source</span>.<span class="property">value</span>] = abspath;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4️⃣ 把代码转换成目标运行环境支持的语法</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    code</span><br><span class="line">  &#125; = babel.<span class="title function_">transformFromAst</span>(<span class="variable constant_">AST</span>, <span class="string">&quot;&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// 与 .babelrc 文件中 presets 的配置相同</span></span><br><span class="line">    <span class="attr">presets</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>], </span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    file, <span class="comment">// 文件</span></span><br><span class="line">    deps, <span class="comment">// 文件依赖</span></span><br><span class="line">    code <span class="comment">// 可执行代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5️⃣ 遍历解析所有的 module</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">parseModules</span> = file =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> entry = <span class="title function_">getModuleInfo</span>(file);</span><br><span class="line">  <span class="keyword">const</span> temp = [entry];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> deps = temp[i].<span class="property">deps</span>;</span><br><span class="line">    <span class="keyword">if</span> (deps) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> deps) &#123;</span><br><span class="line">        temp.<span class="title function_">push</span>(<span class="title function_">getModuleInfo</span>(deps[key]))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> depsObject = &#123;&#125;;</span><br><span class="line">  temp.<span class="title function_">forEach</span>(<span class="function"><span class="params">t</span> =&gt;</span> &#123;</span><br><span class="line">    depsObject[t.<span class="property">file</span>] = &#123;</span><br><span class="line">      <span class="attr">deps</span>: t.<span class="property">deps</span>,</span><br><span class="line">      <span class="attr">code</span>: t.<span class="property">code</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> depsObject</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6️⃣ 打包，返回一个可执行的代码字符</span></span><br><span class="line"><span class="comment">// 1. 立即执行函数，传入相关依赖的JSON。</span></span><br><span class="line"><span class="comment">// 2. 自定义 require 函数， 浏览器不认识 require</span></span><br><span class="line"><span class="comment">// 3. 自定义 exports 对象，浏览器不认识 exports</span></span><br><span class="line"><span class="comment">// 4. 立即执行函数，传入 2中定义的 require、3中定义的 exports 和可以执行的代码字符 code，用 eval 函数执行</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bundle</span> = file =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="variable constant_">DEPSJSON</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">parseModules</span>(file));</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    ;(function (deps) &#123;</span></span><br><span class="line"><span class="string">      function require(f) &#123;</span></span><br><span class="line"><span class="string">        const customRequire = function(path)&#123;</span></span><br><span class="line"><span class="string">          return require(deps[f][&#x27;deps&#x27;][path])</span></span><br><span class="line"><span class="string">        &#125;;</span></span><br><span class="line"><span class="string">        const customExports = &#123;&#125;;</span></span><br><span class="line"><span class="string">        (function(require, exports, code)&#123;</span></span><br><span class="line"><span class="string">          eval(code);</span></span><br><span class="line"><span class="string">        &#125;)(customRequire, customExports, deps[f][&#x27;code&#x27;])</span></span><br><span class="line"><span class="string">        return customExports;</span></span><br><span class="line"><span class="string">      &#125;;</span></span><br><span class="line"><span class="string">      require(&#x27;<span class="subst">$&#123;file&#125;</span>&#x27;);</span></span><br><span class="line"><span class="string">    &#125;)(<span class="subst">$&#123;DEPSJSON&#125;</span>)</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">JSCONTENT</span> = <span class="title function_">bundle</span>(<span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">unlinkSync</span>(<span class="string">&quot;./dist/bundle.js&quot;</span>);</span><br><span class="line">fs.<span class="title function_">rmdirSync</span>(<span class="string">&quot;./dist&quot;</span>);</span><br><span class="line">fs.<span class="title function_">mkdirSync</span>(<span class="string">&quot;./dist&quot;</span>);</span><br><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&quot;./dist/bundle.js&quot;</span>, <span class="variable constant_">JSCONTENT</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  (function() &#123;</span></span><br><span class="line"><span class="comment">//     (0,eval)(&quot;var foo = 123&quot;); // indirect call to eval, creates global variable</span></span><br><span class="line"><span class="comment">//   &#125;)();</span></span><br><span class="line"><span class="comment">//   console.log(foo);            // 123</span></span><br><span class="line"><span class="comment">//   (function() &#123;</span></span><br><span class="line"><span class="comment">//     eval(&quot;var bar = 123&quot;);     // direct call to eval, creates local variable</span></span><br><span class="line"><span class="comment">//   &#125;)();</span></span><br><span class="line"><span class="comment">//   console.log(bar);            // ReferenceError</span></span><br></pre></td></tr></table></figure><p>在根目录下运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node bundle.js</span><br></pre></td></tr></table></figure><p>在<code>dist</code>目录下就生成了编译好的文件，在<code>index.html</code>中引入，就可以正常执行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动手写一个简单的代码编译器，了解一下&lt;code&gt;webpack&lt;/code&gt;的核心原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.lynth.cn/blog/tags/Javascript/"/>
    
      <category term="webpack" scheme="http://www.lynth.cn/blog/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>多git账号如何在同一台电脑使用</title>
    <link href="http://www.lynth.cn/blog/2020/multi-git.html"/>
    <id>http://www.lynth.cn/blog/2020/multi-git.html</id>
    <published>2020-05-15T14:01:47.000Z</published>
    <updated>2022-05-30T07:22:31.461Z</updated>
    
    <content type="html"><![CDATA[<p>公司自己部署了私有Gitlab仓库，个人代码发布在GitHub仓库，git的提交是通过邮箱来识别的，就这导致了私人代码仓库和公司代码仓库用户混淆了。</p><span id="more"></span><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>对<code>ssh</code>协议配置config文件。</p></blockquote><p>1.生成<code>ssh key</code></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># github</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;example@github.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gitlab</span></span><br><span class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa.gitlab -C <span class="string">&quot;example@gitlab.com&quot;</span></span><br></pre></td></tr></table></figure><p>进入<code>~/.ssh</code>会发现新生成了两个文件，分别是<code>id_rsa.pub</code>和<code>id_rsa.gitlab.pub</code></p><p>2.将生成好的秘钥分别上传到<code>Github</code>和<code>Gitlab</code>。</p><p>3.进入<code>~/.ssh</code>目录下，生成config文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> ~/.ssh/config</span><br><span class="line">vi ~/.ssh/config</span><br></pre></td></tr></table></figure><p>添加下面的命令</p><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># git@gitlab.com</span></span><br><span class="line">Host *.gitlab.com</span><br><span class="line"><span class="keyword">User</span> <span class="title">wuyanzu</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa.gitlab</span><br><span class="line"></span><br><span class="line"><span class="comment"># git@github.com</span></span><br><span class="line">Host *.github.com</span><br><span class="line"><span class="keyword">User</span> <span class="title">zuyanwu</span></span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>4.最后验证一下是否配置成功</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@gitlab.com &amp;&amp; ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果出现以下命令，表示配置完成。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Welcome to GitLab, wuyanzu!</span><br><span class="line"></span><br><span class="line">Hi zuyanwu! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在项目下需要设置对应的用户名和邮箱，使用以下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.name <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git config --<span class="built_in">local</span> user.email <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure><p>否则将会使用全局的配置，你也可以更改全局的默认配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx&quot;</span></span><br></pre></td></tr></table></figure><p>或者重置全局配置：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司自己部署了私有Gitlab仓库，个人代码发布在GitHub仓库，git的提交是通过邮箱来识别的，就这导致了私人代码仓库和公司代码仓库用户混淆了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="git" scheme="http://www.lynth.cn/blog/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Javascript EventLoop(浏览器篇)</title>
    <link href="http://www.lynth.cn/blog/2020/javascript-eventloop.html"/>
    <id>http://www.lynth.cn/blog/2020/javascript-eventloop.html</id>
    <published>2020-04-10T00:00:00.000Z</published>
    <updated>2022-05-30T07:22:31.461Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，JavaScript 是一门单线程、非阻塞的脚本语言，目的是为了实现与浏览器的交互。</p><span id="more"></span><h2 id="JavaScript-为什么是单线程的？"><a href="#JavaScript-为什么是单线程的？" class="headerlink" title="JavaScript 为什么是单线程的？"></a>JavaScript 为什么是单线程的？</h2><p>因为为了处理浏览器与用户之间的交互、网络请求以及DOM操作，这就决定了 JavaScript 必须是单线程的，否则就会有产生复杂的同步问题。假设 JavaScript 有两个线程，在一个线程中用户操作了 一个DOM ，另一个线程中又删除了这个 DOM，那这个时候浏览器要怎么处理，以哪个线程为准呢？</p><p>既然是单线程的，那么 JavaScript 的任务就得一个个排队执行，如果遇到到耗时的任务（比如一个网络请求很慢），那后面的任务就执行不了，浏览器就卡着了。这与开头说的 JavaScript 是非阻塞的相矛盾。为了防止主线程的阻塞， JavaScript 就有了 同步 和 异步 的概念。 </p><h2 id="JavaScript-中的同步和异步"><a href="#JavaScript-中的同步和异步" class="headerlink" title="JavaScript 中的同步和异步"></a>JavaScript 中的同步和异步</h2><p><strong>同步</strong>： 如果在函数返回结果的时候，调用者能够拿到预期的结果(就是函数计算的结果)，那么这个函数就是同步的。同步就会产生阻塞，如下面的代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getSeconds</span>() - s &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title function_">wait</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;执行结束！&quot;</span>);</span><br></pre></td></tr></table></figure><br>上面的代码中，console.log() 需要等 wait 函数执行完毕后才会执行。</p><p><strong>异步</strong>： 如果在函数返回的时候，调用者还不能购得到预期结果，而是将来通过一定的手段得到（例如回调函数），这就是异步。例如 Ajax 操作。调用异步函数后，调用者不会立即得到结果，当异步函数获得结果时，会通过回调函数返回调用的结果，所以异步函数不会阻塞线程。  </p><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><p>先了解一下数据结构。</p><p><strong>堆（heap）</strong>：基于树抽象数据类型的一种特殊数据结构。</p><p><strong>栈（stack）</strong>: 栈是遵循后进先出 (LIFO) 原则的有序集合。JavaScript 是单线程的也主要体现在这，因为一个线程只有一个调用栈。调用栈也是有深度限制的，当你写了一个无线递归函数时，浏览器会抛出错误警告（Uncaught RangeError: Maximum call stack size exceeded）。</p><p><strong>队列（queue</strong>）:  队列是遵循先进先出 (FIFO) 原则的有序集合。</p><p>观察一下浏览器中的Event Loop执行模型：<br><img src="/blog/images/EventLoop.png" alt="Loop"></p><p>如图可知，JavaScript 中分为 <strong>堆内存</strong> 和 <strong>栈内存</strong>。</p><p>JavaScript 中的引用数据类型的大小是不固定的，所以它们就储存在堆内存中。JavaScript 不允许直接访问堆内存中的位置，所以也不能直接去操作它的内存空间，而是操作 <strong>对象的引用</strong>。引用数据类型（ 对象(Object) ）的指针储存在栈内存中，该指针指向了堆内存中该实体的起始地址。顺带一提，当形成闭包的时候，实际上作用域链也是保存到了堆中。</p><p>JavaScript 中的基本数据类型就储存在栈内存中，它们占用的大小和空间固定，是直接 <strong>按值来访问</strong> 的。</p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>当打开一个网页时，浏览器会将代码传递给引擎去执行，引擎首页会创建一个全局执行环境。全局环境中的代码自上而下有顺序的执行，当遇到一个函数时，JavaScript 会生成一个与这个函数对应的执行环境，又叫做 <strong>执行上下文（Context）</strong>[1]。这个执行上下文中保存着这个函数的私有作用域、作用域链、参数、此函数作用域中定义的变量和 this 的指向。当这个函数执行完以后，当前执行上下文将从栈中弹出，上下文的控制权限将转移到当前执行栈的下一个执行上下文。当一系列的函数被调用时，这些函数就会按照顺序排列在一个地方，按照类似于栈的控制机制执行，这个地方就是称之为的执行栈。</p><h4 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h4><p>任务队列是一个存放着很多 <strong>异步任务</strong> 的有序 <strong>集合</strong>（注意不是队列，因为执行的机制与队列的执行机制是不一样的。在队列中，是队列中的第一个出队。而在任务队列中，是事件循环执行模型抓取任务队列中第一个可以执行的任务）。一个事件循环中存在一个或多个任务队列，每个任务都来自一个特定的任务源。来自特定任务源和指向特定的事件循环的所有任务都必须被添加到同一个任务队列，来自不同任务源的任务可以被添加到不同的任务队列中。  </p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。每个代理都有一个关联的事件循环，该事件循环对于该代理是唯一的。</p><p>HTML标准中的事件循环进程模型，概括如下：</p><ol><li><p>选择一个包含至少有一个可执行的任务的任务队列作为当前的要执行的任务队列（下面称为 <em>taskQueue</em>），如果没有这样的队列，就跳转至 <strong>microtask 的执行步骤</strong>。</p></li><li><p>从 <em>taskQueue</em> 中选择第一个可执行的任务作为 <em>oldestTask</em>，从 <em>taskQueue</em> 中移除 <em>oldestTask</em>。</p></li><li><p>将事件循环的当前运行中的任务设置为 <em>oldestTask</em>。</p></li><li><p>执行任务。</p></li><li><p>将事件循环的当前运行中的任务设置为 null。</p></li><li><p>进入 microtask 执行步骤。</p></li><li><p>更新渲染</p></li><li><p>循环这整个过程…</p></li></ol><p>进入到 <strong>microtask 的执行步骤</strong>：</p><ol><li><p>如果执行 microtask 步骤标识为 true，则退出执行。</p></li><li><p>设置执行 microtask 步骤标识为 true。</p></li><li><p>如果事件循环中的微任务队列不为空：</p><p>3.1 设置事件循环的微任务队列中第一个任务为 <em>oldestMicrotask</em>。</p><p>3.2 将事件循环的当前运行中的任务设置为 <em>oldestMicrotask</em>。</p><p>3.3 执行 <em>oldestMicrotask</em>。</p><p>3.4 将事件循环的当前运行中的任务设置为 null。</p></li><li><p>将事件循环的 执行 microtask 步骤表示设置为 false。  </p></li></ol><p>下面是根据我理解的事件循环进程模型画出来的示意图。  </p><p><img src="/blog/images/Process.png" alt="Process">  </p><p>用文字描述可以解释为：所有的同步任务都会在执行栈立即执行然后出栈，异步任务会进入到异步任务处理模块，然后把异步任务结果放到任务队列中。当执行栈中所有同步任务执行完以后就会去检查任务列队，如果任务队列为空，就会去检查微任务队列，如果有微任务就一次执行完所有的微任务。循环进行 <strong>任务入栈执行任务</strong>，<strong>栈为空</strong>，<strong>检查任务队列</strong> 的步骤，这个过程不断重复，这就是事件循环。</p><p><strong>总结：1.宏任务队列每执行完一个任务就会去检查微任务队列。2.微任务队列中的任务会按照顺序一次执行完成（微任务执行产生的微任务会被加入到队尾，在这个周期被执行），直至微任务队列为空。</strong>  </p><h4 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h4><p>宏任务：script(整体代码)、setTimeout、setInterval、I/O、事件、postMessage、 MessageChannel、setImmediate (Node.js)</p><p>微任务：Promise.then、 MutaionObserver、process.nextTick (Node.js)</p><p>引用文章《微任务、宏任务与 Event-Loop》中的例子来介绍一下宏任务与微任务的关系。</p><p>在银行办业务的时候，假设这个银行只有一个窗口，每个客户都会取号排队在这个窗口办理业务。把每一个客户比作 <strong>宏任务</strong>，那么接待下一位客户的过程就是 <strong>宏任务</strong> 进入到执行栈的过程。这些排队的客户就形成了一个 任务队列。当客户在窗口办理完业务，业务员会问客户，还有什么可以帮您的吗？这时候如果客户还有其他一些事情要办，那么在还会继续占用着窗口办理业务，其他客户也只能等着，客户的其他事情就像是 <strong>微任务</strong>。这表明，<strong>在当前微任务没有执行完成时，是不会执行下一个宏任务的</strong>。根据例子，可以总结出：<strong>宏任务与微任务不在同一个队列中，且微任务的执行优先于宏任务</strong>。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>学习那么多理论知识，让我们来检查一下学习成果吧，下面抛出一道烂大街的笔试题。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">function</span>(<span class="params">resolve</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>心里想的答案与实际结果一样吗？不一样也没关系，不要气馁。是不是在 <strong>async/await</strong> 上遇到了的问题？让我帮帮你吧！</p><p><strong>async/await</strong> 只是语法糖而已，只要把它转换成 <strong>Promise</strong> 的形式，你就会一目了然了。例如下面代码：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// await 前面的代码</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">load</span>();</span><br><span class="line">    <span class="comment">// await 后面的代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>();</span><br></pre></td></tr></table></figure><p>await 前面的代码是同步的，调用函数的时候会直接执行；<strong>await load()</strong> 可以被转换成 <strong>Promise.resolve(load())</strong>；await 后面的代码则会被放到 <strong>Promise.then()</strong> 中。这样代码就会被转换成下面的形式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetch</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// await 前面的代码</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">load</span>()).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// await 后面的代码</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">load</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fetch</span>();</span><br></pre></td></tr></table></figure><p>试着转换一下测试题，然后重新运算一下结果，这样是不是就容易多了？</p><p>那么恭喜你，你已经掌握了本篇文章涉及的知识点。</p><p>说道最后：推荐去看一下 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">HTML5标准 - Event Loop</a> 原文。还有就是，好记性不如烂笔头，根据自己的理解，试着画一下 <strong>Event Loop 执行模型</strong> 的流程图来巩固一下知识吧！</p><blockquote><p>参考：<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">[MDN] 并发模型与事件循环</a><br><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">HTML5标准 - Event Loop</a><br><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a><br><a href="https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0">Understanding Execution Context and Execution Stack in Javascript</a><br><a href="https://juejin.im/post/5cbc0a9cf265da03b11f3505">最后一次搞懂 Event Loop</a><br><a href="https://vimeo.com/96425312">Philip Roberts: Help, I’m stuck in an event-loop.</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，JavaScript 是一门单线程、非阻塞的脚本语言，目的是为了实现与浏览器的交互。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://www.lynth.cn/blog/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>个性化Shell终端折腾</title>
    <link href="http://www.lynth.cn/blog/2017/custom-shell.html"/>
    <id>http://www.lynth.cn/blog/2017/custom-shell.html</id>
    <published>2017-03-04T16:05:32.000Z</published>
    <updated>2022-05-30T07:22:31.461Z</updated>
    
    <content type="html"><![CDATA[<p>在MAC环境下自定义shell终端的配色方案。<br>iterm2 + oh my zsh</p><span id="more"></span><h2 id="安装iterm2"><a href="#安装iterm2" class="headerlink" title="安装iterm2"></a>安装iterm2</h2><p><a href="http://www.iterm2.com/downloads.html">下载地址</a></p><h2 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh | sh</span><br></pre></td></tr></table></figure><p>安装完成后，切换<code>dash</code>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><br>切换为原来的<code>dash</code>:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chsh -s /bin/bash</span><br></pre></td></tr></table></figure><br>卸载oh-my-zsh:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uninstall_oh_my_zsh</span><br></pre></td></tr></table></figure></p><h2 id="设置配色方案"><a href="#设置配色方案" class="headerlink" title="设置配色方案"></a>设置配色方案</h2><p>使用 <a href="http://ethanschoonover.com/solarized">Solarized</a> 配色方案:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">git <span class="built_in">clone</span> git://github.com/altercation/solarized.git</span><br><span class="line"><span class="comment">#配置</span></span><br><span class="line"><span class="built_in">cd</span> solarized</span><br><span class="line"><span class="built_in">cd</span> vim-colors-solarized/colors</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.vim/colors</span><br><span class="line"><span class="built_in">cp</span> solarized.vim ~/.vim/colors/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#更改vim配色方案，和终端保持一致</span></span><br><span class="line">vi ~/.vimrc</span><br><span class="line"><span class="comment">#写入</span></span><br><span class="line">syntax <span class="built_in">enable</span></span><br><span class="line"><span class="built_in">set</span> background=dark</span><br><span class="line">colorscheme solarized</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置ls高亮</span></span><br><span class="line"><span class="comment">#安装coreutils</span></span><br><span class="line">brew install coreutils</span><br><span class="line">vi ~/.bash_profile</span><br><span class="line"><span class="comment">#写入</span></span><br><span class="line"><span class="built_in">export</span> CLICOLOR=1</span><br></pre></td></tr></table></figure></p><h2 id="设置语法高亮"><a href="#设置语法高亮" class="headerlink" title="设置语法高亮"></a>设置语法高亮</h2><p>使用 <a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source <span class="variable">$&#123;(q-)PWD&#125;</span>/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot;</span> &gt;&gt; <span class="variable">$&#123;ZDOTDIR:-<span class="variable">$HOME</span>&#125;</span>/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></p><h2 id="设置主题"><a href="#设置主题" class="headerlink" title="设置主题"></a>设置主题</h2><p>使用主题 <a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor">agnoster</a>。   </p><h4 id="此款主题需要字体"><a href="#此款主题需要字体" class="headerlink" title="此款主题需要字体"></a>此款主题需要字体</h4><p><a href="https://github.com/powerline/fonts">下载地址</a>  </p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#更改配置文件</span></span><br><span class="line">vi ~/.zshrc</span><br><span class="line"><span class="comment">#写入</span></span><br><span class="line">ZSH_THEME=<span class="string">&quot;agnoster&quot;</span></span><br></pre></td></tr></table></figure><h2 id="成果"><a href="#成果" class="headerlink" title="成果"></a>成果</h2><p><img src="http://image.lynth.cn/img/shell/zsh.png" alt="on-my-zsh"><br><img src="http://image.lynth.cn/img/shell/zsh1.png" alt="on-my-zsh"></p><blockquote><p>参考：<br><a href="http://www.vpsee.com/2013/09/use-the-solarized-color-theme-on-mac-os-x-terminal/">在 Mac OS X 终端里使用 Solarized 配色方案</a><br><a href="http://www.jianshu.com/p/7de00c73a2bb">iTerm 2 &amp;&amp; Oh My Zsh【DIY教程——亲身体验过程】</a><br><a href="http://www.jianshu.com/p/e4973be9c9fb">Mac下iTerm 2语法高亮配置及附带美化</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在MAC环境下自定义shell终端的配色方案。&lt;br&gt;iterm2 + oh my zsh&lt;/p&gt;
    
    </summary>
    
    
      <category term="Shell" scheme="http://www.lynth.cn/blog/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>学习 CSS3 属性 writing-mode</title>
    <link href="http://www.lynth.cn/blog/2016/writing-mode.html"/>
    <id>http://www.lynth.cn/blog/2016/writing-mode.html</id>
    <published>2016-12-14T00:00:00.000Z</published>
    <updated>2022-05-30T07:22:31.465Z</updated>
    
    <content type="html"><![CDATA[<p><strong>writing-mode</strong> 是控制内联元素的显示的，和 float 属性有些类似，<strong>writing-mode</strong> 可以实现文字竖向的排版。</p><span id="more"></span><h3 id="writing-mode语法"><a href="#writing-mode语法" class="headerlink" title="writing-mode语法"></a>writing-mode语法</h3><p>writing-mode有两套语法，一套是IE私有的，一套是CSS规范属性。</p><h4 id="CSS3语法"><a href="#CSS3语法" class="headerlink" title="CSS3语法"></a>CSS3语法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 关键字值 */</span></span><br><span class="line"><span class="attribute">writing-mode</span>: horizontal-tb;    <span class="comment">/* 默认值 */</span></span><br><span class="line"><span class="attribute">writing-mode</span>: vertical-rl;</span><br><span class="line"><span class="attribute">writing-mode</span>: vertical-lr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局值-关键字 */</span></span><br><span class="line"><span class="attribute">writing-mode</span>: inherit;</span><br><span class="line"><span class="attribute">writing-mode</span>: initial;</span><br><span class="line"><span class="attribute">writing-mode</span>: unset;</span><br></pre></td></tr></table></figure><ul><li>默认值<strong>horizontal-tb</strong>表示文本流是水平方向(horizontal)的，元素是从上往下<strong>(tb:top-bottom)</strong>堆叠的。</li><li><strong>vertical-rl</strong>表示文本是垂直方向(vertical)展示，然后阅读的顺序是从右往左<strong>(rl:right-left)</strong>，跟我们古诗的阅读顺序一致。</li><li><strong>vertical-lr</strong>表示文本是垂直方向(vertical)展示，然后阅读的顺序还是默认的从左往右<strong>(lr:left-right)</strong>，也就是仅仅是水平变垂直。</li></ul><p>下面是各个值下的中英文表现对照（参考自<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/writing-mode">MDN</a>）：<br><img src="http://image.lynth.cn/img/writingmode/writing-mode.png" alt="对照表"><br><em>使用<strong>text-orientation:upright</strong>可让英文字符竖立，IE不支持，FF和Chrome支持。</em></p><h4 id="IE浏览器语法"><a href="#IE浏览器语法" class="headerlink" title="IE浏览器语法"></a>IE浏览器语法</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-ms-<span class="attribute">writing-mode</span>: lr-tb | rl-tb | tb-rl | bt-rl | tb-lr | bt-lr | lr-bt | rl-bt | lr | rl | tb</span><br></pre></td></tr></table></figure><ul><li><strong>lr-tb</strong><br>初始值。内容从左往右(left-right)，从上往下(top-bottom)水平流动，以及下一行水平元素在上一行元素的下面，所有符号都是直立定位。大部分的书写系统都是使用这种布局。</li><li><strong>rl-tb</strong><br>内容从右往左(right-left，从上往下(top-bottom)水平流动，以及下一行水平元素在上一行元素的下面，所有符号都是直立定位。这种布局适合从右往左书写的语言，例如阿拉伯语，希伯来语，塔安那文，和叙利亚语。</li><li><strong>tb-rl</strong><br>内容从上往下(top-bottom)，从右往左(right-left)垂直流动， 下一个垂直行定位于前一个垂直行的左边，全角符号直立定位，非全角符号(也可以被称作窄拉丁文或者窄假名符号)顺时针方向旋转90°。这种布局多见于东亚排版。</li><li><strong>bt-rl</strong><br>内容从下往上(bottom-top)，从右往左(right-left)垂直流动， 下一个垂直行定位于前一个垂直行的左边，全角符号直立定位，非全角符号(也可以被称作窄拉丁文或者窄假名符号)顺时针方向旋转90°。此布局多见于在东亚垂直排版从右往左的文本块上。</li><li><strong>tb-lr</strong><br>IE8+浏览器支持。 内容从上往下(top-bottom)，从左往右(left-right)垂直流动。下一个垂直行在前一个的右边。</li><li><strong>bt-lr</strong><br>IE8+浏览器支持。 内容从下往上(bottom-top)，从左往右(left-right)垂直流动。</li><li><strong>lr-bt</strong><br>IE8+浏览器支持。 内容从下往上(bottom-top)，从左往右(left-right)水平流动。下一个水平行在前一行的上面。</li><li><strong>rl-bt</strong><br>IE8+浏览器支持。内容从下往上(bottom-top)， 从右往左(right-left)水平流动。</li><li><strong>lr</strong><br>IE9+浏览器支持。在SVG和HTML元素上使用。等同于<strong>lr-tb</strong>.</li><li><strong>rl</strong><br>IE9+浏览器支持。在SVG和HTML元素上使用。等同于<strong>rl-tb</strong>.</li><li><strong>tb</strong><br>IE9+浏览器支持。在SVG和HTML元素上使用。等同于<strong>tb-rl</strong>.</li></ul><p>各个属性值的表现如下（参考自<a href="https://msdn.microsoft.com/en-us/library/ms531187%28v=vs.85%29.aspx">微软</a>）<br><img src="http://image.lynth.cn/img/writingmode/writing-mode1.jpg" alt="对照表"></p><blockquote><p>参考：<br><a href="http://www.zhangxinxu.com/wordpress/?p=5352">改变CSS世界纵横规则的writing-mode属性</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;writing-mode&lt;/strong&gt; 是控制内联元素的显示的，和 float 属性有些类似，&lt;strong&gt;writing-mode&lt;/strong&gt; 可以实现文字竖向的排版。&lt;/p&gt;
    
    </summary>
    
    
      <category term="CSS3" scheme="http://www.lynth.cn/blog/tags/CSS3/"/>
    
  </entry>
  
</feed>
